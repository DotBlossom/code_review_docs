## 개요
  
    개요 : 문제를 글 처럼 읽고, 핵심 단어들을 기반으로 논리적 추론을 시작하고, 진행하고, 끝내는 방법을 보여줌니다. 
    알고리즘은 이런 논리적 추론 과정에서 자연스레 필요한 요소들이 떠오르는 것이고, 이렇게 끊임없이 전체 흐름을 생각하며 추론을 진행하면, 
    무조건 답으로 수렴하게 되는게 "문제를 위한 문제"의 특징입니다.
    
    제 글과 일반 해설과의 차이점은, 
    
    일반 해설은 핵심 논리에 대한 설명만 딱 하고 던집니다.
    → 이해는 되더라도 “사람 바이 사람”에 의거해 추후에 일관적인 방법으로 적용이 안됨. 모든 케이스를 암기하고 숙지하는 느낌
    
    제 글은 핵심 논리까지 가기위해서, 문제 안에 있는 모든 요소들을 통해 이 핵심논리를 도출하는 일반적인 사고 과정을 항상 서술해 놓습니다.
    → 항상 문제 안에 있는 단어와 맥락으로부터 추론을 시작하고 설계. 이런 문제 속 내용들을 기준으로 설계를 시작하며, 
    나머지 알고리즘이나 컴퓨터 과학적인 내용은 이 설계를 하는 과정에서 자연스럽게 떠올라야 합니다.



## example 1

    내 풀이
    
    이 말의 의미는, 문제에서 왜 굳이 **‘생성점’을** 따로 정의했으며, 그래프로 생성된 도형들을 **Node의 개수와 edge의 특성으로 정의를 함.**
    
    그리고 특정 점에서, 실**제 그래프를 탐색하는 관점에서 문제를 서술**하고 있다. 즉, 점과 선을 직접 simulate 하면서, 문제를 파악하는 구조를 느낄 수 있음.
    
    → 결론적으로, 이런 위상 객체들을, 주어진 특징 + 문제에서 제시한 객체들을 통해, 가장 빠르게 문제 풀이법을 도출할 수 있음.
    
    그리고, 문제를 모두 읽었을 때 + 문제에서 **제시하는 요구사항 + 실제 자료형**을 종합했을 때. 가장 핵심적인 것은 무엇인가?
    
    → **3개의 위상케이스를 분리해보자.** 어떻게? 위에 읽은 맥락을 모두 담아서 가장 빠른 방법으로.
    
    1. 가장 첫번째로 드는 생각은, **생성점을 준 이유와, 나머지 맥락의 관계**임.
    2. 맥락 중 가장 핵심은, 계속 언급 중인, 실제 그래프 간의 위상적 특징을 확정 짓는, 정점을 기준으로 간선을 도는 관계임.
    3. **생섬점은, 이러한 관점에서 다른 위상 객체들과 분별되는 특징이 존재함을 알게됨.**
    4. 만약 생성점에서, OUT이 2개 미만이라면, 생성점이 아닌 일반 그래프 객체에 종속됨
    5. **나머지 객체들은 어떻게 분리할 것인가 ?** (위에 추론한 특징을 기반으로 시작하자, 위에 추론한 특징을 사용할 수 있는 이유는, 
    문제의 맥락과 문제의 해결목적 모두에 부합하기때문에, 자신의 로직을 믿고 달려가도되는거임. 이런 문제를 위한 문제의 구조는 다 뻔함. 
    국제수학올림피아드도 똑같음. 이런 한계가 있어서, 지능이 동일해도 누군간 잘풀고 누군간 못푸는거임 )
    6. 생성점에 종속된 나머지 객체들은 하나의 도형 시작점일 확률이 크다.
    7. 여기서부터 **하나씩 graph 탐색을 각각 Divide하여 접근하자.**(여기가 알고리즘 파트 단 한개. 아주 기초 알고리즘임.
    이 위에 전개를 구현하지 못하고 알고리즘을 그냥 숙지하니 문제를 못푸는거임, 순서가 잘못됬다는거임. 아 문제유형,,? BFS! 이러고 풀면 사실상 더 가시밭길이라는거임. 
    거기에 사고가 아예 얽매이기 시작해서, 위에 필요한 전개 생각하는데 거추장스러움. )
    8. ~~(만약 k-v가 명시적인 자료객체를 사용한다면, 여러 잡기술을 사용해서 k-v;m-k로 개빠르게 추출)~~
    9. 직선은 결국, 탐색시 끝이 존재하는경우.
    10. 일반 도넛? 은 시작점을 기준으로 cycle로 인해 다시 시작점으로 돌아옴, 시작점을 Memo하여, 노드 진행도중 시작점에 다시 도달하면 종료.
    11. 중첩 도넛은? 일반도넛들을 새다가, 동일한 정점(결국 처음부터 특징점을 정의한게 매우 중요함) Memo Hit되면 중첩 케이스로 cnt 관리

## example 2 
    **Sol. 맥락을 유지하면서 글을 읽는 것은 동일함**
    
    결국 (부모와) 연결된 길, 연결되지 않은 길이 맥락속에서 의미를 지닐 가능성이 크다. 
    
    그리고 1,2,3 이라는 값을 임의적으로 사용이 가능함. 
    
    연결된 길은, **계속 Circulate 됨**을 알 수있음, 고정된 순서이고, 연결된 길은 **숫자 값을 보내 줄 수 있다.**
    
    → 결국, 리프 노드에서 값을 기다리다가 채우는 상황이 아닌가?
    
    → 근데 잘 보면, 이러한 값을 보내주는 행위는 사실상 순서가 보장되어있는것이 아닌가?
    
    → 문제를 읽어보면 가장 작은 순서대로 리턴하라는데, 예시를 봐보니, 이렇게 순서를 고려해서 배열을 보면, 
    
    대가리가 아프니 슬슬 가장 아래에 실제 케이스를 봐보자.
    
    > [*3, 2, 1, 1, 3]순으로 숫자를 떨어트리거나 [1, 1, 1, 1, 2, 1, 3]순으로 숫자를 떨어트려도 target과 같게 만들 수 있지만,
    > 가장 적은 숫자를 사용하며 그중 사전 순으로 가장 빠른 경우는 [1, 1, 3, 2, 3]입니다.*
    
    결국 순서가 고정되어있다는 가정하에 생각해보면, 하나의 리프노드에 할당되는 값은
    3,1,3 이고
    1,3,3 이다.
    
    그냥 Greedy Maximizer를 통해 다 채워버리고, 노드 개수에서 도출되는 pattern값으로 정렬 떄리면 아무 문제가 없다.
    > 
    
    *~~→ 그리고 우리가 글을 잘 읽었다면, 맥락 속에서 하나 고려하지 않은 조건과, 문제의 제약조건이 각각 1개씩 남음을 알 수있다.~~*
    
    *~~→ 1,2,3이라는 값과, 실제 노드를 만들수 있는가에 대한거다.~~*
    
    *~~→ 즉, [0,7,1] 과 같이, 하나의 노드엔 7을 채우고 하나의 노드에는 1을 채우는 케이스가 가능한건가? 를 물어보면 x이다.~~*
    
    *~~→ 결론적으로, 7을 채우는 동안, 1에도 필연적으로 turn이 돌아가고, 이것은 해 존재의 유효성을 기각시킴. : -1~~*
    
    *~~→ 그러면 사전적으로 값을 filter해 버릴수 있음을 느낄 수 있음~~* 
    
    *~~→ 각 리프노드의 값들이 Max[Arg] → 3, Min[Arg]→ 1 을 부여할때 그 값이 타당하게 부등식을 만족할 수 있나? 로 1번의 계산으로 유효성을 바로 기각할 수 있다. (무시 가능, 알면 좋고)~~*
    
    → 이렇게 문제를 한번 읽으면서 , 우리는 각 노드들이 독립적으로 작동한 다는 것을 알 수 있음. 
    
    위에 내용을 다시 한번 생각해보면 자연스럽게, 각 노드가 마치 스위치처럼 딸깍이면서 작동하는것을 느낄.. 수있지..? 아.. 머리아파져서 설명을 몬하겠네
    
    → 결국, 아무리 큰 트리라고 할 지 언정, 최종 노드 그림만 위에 예시정도의 볷잡도로 생각하면 모두 풀릴 수 있음을 알 수 있음. 독립적으로 각각 작동하니까.
    
    → 이제 내부 로직을 상세히 구현해보자 **(이런 점에서는 7번의 가치를 할수도? )**
    
    → 결국 각 노드(독립성을 검토했으니)들은, 차례가 돌아올때, 값을 얼마나 채울수 있을까. 실제 채울수나 있을까 라는 생각을 해야함.
    
    → **결국 주어진 수는 [1,2,3]이다. 우리가 할수 있는건, 자기 차례에 왔을때, 어떻게든 1을 박아서 최소한으로 값을 다 채우든 3으로 값을 다 채우든, 
    하나의 circle에서 이 행위가 가능한가 검토해야함(이거 생각하면 문제 끝.)**
    
    → 스위치 딸깍을 하나씩 생각해보면, 첫번째 길부터 가장 마지막 노드가 통하는 길까지의 한번의 cycle을 circle로 정의할 수 있음
    
    → 여기서 하나의 식을 도출할 수 있지않을까 라는 생각이 듦.(각 노드가 독립적이며, 동시에 사이클 내에 존재하니까)
    
    → 자, 식을 만들어 보려고 하니 1,2,3을 Max. Min Case로 값을 실제로 부여한다면, 대가리가 힘들지 않을까? 라는 생각이 듦. (이건 경험이 아닐까? 수학적 문제를 많이 접하다보면, 전개하려하니 숨이 턱막히는 그런 감각)
    
    → 그리고 위에 논리를 다시 생각해보면, 결국 값은 ~~추후에 Sig(1≤ K ≤ 3)x로 부여가 가능 하지 않냐? 라는 생각이 듦.~~
    
    → 저런 생각을 했다면, 그냥 Sig가 중요한게 아닌, 숫자가 부여된 개수가 key라는게 딱 이제 자
    
    → 결국, 실제 Target 값과, circle 내 존재하는 숫자의 개수에 특정 가중치(1,3)를곱해서 걍 전개하면 될 거같은데? 
    
    <aside>
    💡
    
    → **결국 주어진 수는 [1,2,3]이다. 우리가 할수 있는건, 자기 차례에 왔을때, 어떻게든 1을 박아서 최소한으로 값을 다 채우든 3으로 값을 다 채우든, 
    하나의 circle에서 이 행위가 가능한가 검토해야함(이거 생각하면 문제 끝.)**
    
    </aside>
    
    이 부분을 이미 맥락속에서 추론했기 떄문에 가능했다.
    
    →  **부여된 cnt * 1 ≤ target 값 ≤ 부여된 cnt * 3 (여기서 드디어 핵심이 도출됨)**
    
    → ㅄ같은 값의 BOUND+ circle 구조때매, **부등식의 lowerbound를 고려**해야하고, 계속 turn 마다 세는게 훨씬 건강에 이득이 될 것만 같다
    
    → 정리하자면, 
    
    **부여된 cnt * 1 ≤ target 값 ≤ 부여된 cnt * 3,**
    
    그냥 Greedy Maximizer를 통해 다 채워버리고, 노드 개수에서 도출되는 pattern값으로 정렬[node 개수를 하나의 cycle로 생각하고 N을 C_i로 분할] 떄리면 아무 문제가 없다.
    
    → 실제로 구현까지 30분 정도 걸리는거 같음.
    → 잘 보면 알겠지만, 이런식으로 계속 맥락을 다 고려하고 생각하며 풀면, 그냥 .. 뭐 .. 시간복잡도 이딴거 알아서 다 맞춰짐. 그냥 뇌피셜로 상상해서 푸니까 다 시간초과 뜨는거고, 못푸는거임 ..
    → 문제를 다푸는건 딱히 중요한건 아님. 이건 걍 지적유희 그이상 그이하도 아니니까요. 근데  중요한건,  이런 문제를 풀때, 이거보다 더 쉽더라도(다 쉽겠지, 이게 최종보스문제 번호니까), 
    3시간 동안 순수하게 대가리를 스무스하게 굴릴수있는 사고적 지구력을 키우는게 제일 중요함. 이런문제 1시간 잡고(첨이니까 1시간 주면 풀려나?) 안쉬고 1시간을 풀로 채우고**, 
    모든 사고에 근거를 달아가며 해야함. 맥락을 벗어나도 안되고, 조건을 유기해도 안되고, 사고적 비약도 모두 근거와 맥락에 기반하여 해야됨 (처음으로 논리적 문제 풀어보는거니까?)**
